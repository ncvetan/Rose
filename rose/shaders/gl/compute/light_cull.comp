#version 460 core

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// determines which lights are part of each cluster

// defines a cell within a light grid containing offset into light list
// of the particular cluster and how many lights are within the cluster
struct GridCell {
    uint offset;
    uint n;
};

// defines the bounds of a cluster
struct AABB {
    vec4 max_pt;
    vec4 min_pt;
};

struct DirLight {
	vec3 direction;
	vec3 color;
};

// light parameters for a particular point light
struct PointLight {
	vec4 color;
	float linear;
	float quad;
	float intensity;
	float radius;
};

layout (std140, binding = 1) uniform globals {
	mat4 projection;
	mat4 view;
	vec3 camera_pos;
	DirLight dir_light;
	uvec3 grid_sz;				// cluster dimensions (xyz)
	uvec2 screen_dims;			// screen [ width, height ]
	float far_z;
	float near_z;
};

// aabb defining each cluster, computed the list clusters_aabb compute shader
layout (std430, binding=2) buffer clusters_ssbo {
    AABB cluster_aabb[];
};

// specifies an offset into 'indices' and a count, specifying which lights are active in the cluster
layout (std430, binding=3) buffer light_grid_ssbo {
    GridCell light_grid[];
};

// list of active lights in scene
layout (std430, binding=4) buffer indices_ssbo {
    uint indices[];
};

// global list of light parameters
layout (std430, binding=5) buffer lights_ssbo {
    PointLight lights[];
};

// global list of light positions (this should always have the same length as lights_ssbo)
layout (std430, binding=6) buffer lights_pos_ssbo {
    vec4 lights_pos[];
};

// used across workgroups to determine where each cluster will write into the indices_ssbo
layout (std430, binding=7) buffer indices_idx_ssbo {
    uint indices_idx;
};

// tests a sphere to see if it affects the given cluster
bool sphere_aabb_test(uint light_idx, uint cluster_idx) {    
    float sq_radius = pow(lights[light_idx].radius, 2);
    vec4 light_pos = lights_pos[light_idx];
    float dist = 0.0;

    AABB aabb = cluster_aabb[cluster_idx];

    if (light_pos.x < aabb.min_pt.x) dist += pow(light_pos.x - aabb.max_pt.x, 2); 
    else if (light_pos.x > aabb.max_pt.x) dist += pow(light_pos.x - aabb.max_pt.x, 2);
    if (light_pos.y < aabb.min_pt.y) dist += pow(light_pos.y - aabb.max_pt.y, 2); 
    else if (light_pos.y > aabb.max_pt.y) dist += pow(light_pos.y - aabb.max_pt.y, 2);
    if (light_pos.z < aabb.min_pt.z) dist += pow(light_pos.z - aabb.max_pt.z, 2); 
    else if (light_pos.z > aabb.max_pt.z) dist += pow(light_pos.z - aabb.max_pt.z, 2);  

    return (dist <= sq_radius);
}

void main() {
    indices_idx = 0;    // reset on each frame

    uint n_total_lights = lights.length();
    uint cluster_idx = gl_LocalInvocationIndex.x + 128 * gl_WorkGroupID.x;

    uint n_local_lights = 0;        // number of lights in this cluster
    uint visible_light_idxs[100];   // buffer to store light indices for this cluster

    // check each light to see if it intersects this cluster's aabb
    // add indices of lights that do intersect to local list
    for (uint light_idx = 0; light_idx < n_total_lights; ++light_idx) {        
        if (sphere_aabb_test(light_idx, cluster_idx) && n_local_lights < 100) {
            visible_light_idxs[n_local_lights] = light_idx;
            n_local_lights++;
        }
    }   
    
    barrier();  // TODO: I don't think this barrier is necessary (it is for making sure indices_idx is zero before threads start to write to it)

    // offset is the unmodified value of indices_idx
    uint offset = atomicAdd(indices_idx, n_local_lights);

    for (uint i = 0; i < n_local_lights; ++i) {
        indices[offset + i] = visible_light_idxs[i];
    }

    light_grid[cluster_idx] = GridCell(offset, n_local_lights);
}