#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// determines which lights are part of each cluster

// defines a cell within a light grid containing offset into light list
// of the particular cluster and how many lights are within the cluster
struct GridCell {
    int offset;
    int n;
};

// defines the bounds of a cluster
struct AABB {
    vec4 max_pt;
    vec4 min_pt;
};

// light parameters for a particular point light
struct PointLight {
	vec3 color;
	float linear;
	float quad;
	float intensity;
	float radius;
};

// aabb defining each cluster, computed the list clusters_aabb compute shader
layout (std430, binding=2) buffer clusters_ssbo {
    AABB cluster_aabb[];
};

// specifies an offset into 'indices' and a count, specifying which lights are active in the cluster
layout (std430, binding=3) buffer light_grid_ssbo {
    GridCell light_grid[];
};

// list of active lights in scene
layout (std430, binding=4) buffer indices_ssbo {
    int indices[];
};

// global list of light parameters
layout (std430, binding=5) buffer lights_ssbo {
    PointLight lights[];
};

// global list of light positions (this should always have the same length as lights_ssbo)
layout (std430, binding=6) buffer lights_pos_ssbo {
    vec4 lights_pos[];
};

// used across workgroups to determine where each cluster will write into the indices_ssbo
layout (std430, binding=7) buffer indices_idx_ssbo {
    uint indices_idx;
};

uniform mat4 view;          // view matrix

// tests a sphere to see if it affects the given cluster
bool sphere_aabb_test(uint light_idx, uint cluster_idx) {    
    float sq_radius = pow(lights[light_idx].radius, 2);
    vec4 center = lights_pos[light_idx];
    float dist = 0.0;

    AABB aabb = cluster_aabb[cluster_idx];

    if ( center.x < aabb.min_pt.x ) dist += pow(center.x - aabb.max_pt.x, 2); 
    else if ( center.x > aabb.max_pt.x ) dist += pow(center.x - aabb.max_pt.x, 2);
    if ( center.y < aabb.min_pt.y ) dist += pow(center.y - aabb.max_pt.y, 2); 
    else if ( center.y > aabb.max_pt.y ) dist += pow(center.y - aabb.max_pt.y, 2);
    if ( center.z < aabb.min_pt.z ) dist += pow(center.z - aabb.max_pt.z, 2); 
    else if ( center.z > aabb.max_pt.z ) dist += pow(center.z - aabb.max_pt.z, 2);  

    return (dist <= sq_radius);
}

void main() {
    indices_idx = 0;    // resets on each frame

    uint n_total_lights = lights.length();                                              // total lights in scene
    uint n_threads = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;      // number of threads in a group

    uint cluster_idx = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;

    uint n_local_lights = 0;        // number of lights in this cluster
    uint visible_light_idxs[100];   // buffer to store light indices for this cluster

    // check each light to see if it intersects this cluster's aabb
    // add indices of lights that do intersect to local list
    for (uint light_idx = 0; light_idx < n_total_lights; ++light_idx) {        
        if (sphere_aabb_test(light_idx, cluster_idx)) {
            visible_light_idxs[n_local_lights] = light_idx;
            n_local_lights++;
        }
    }   
    
    barrier();  // TODO: I don't think this barrier is necessary

    uint offset = atomicAdd(indices_idx, n_local_lights);

    for (uint i = 0; i < n_local_lights; ++i) {
        indices[offset + i] = visible_light_idxs[i];
    }

    light_grid[cluster_idx] = { offset, n_local_lights };
}